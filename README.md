# java-ladder

2022 마스터즈 백엔드 사다리 게임 프로젝트

## 1단계 - 기본 기능 구현

### 요구사항

- [x] n명의 사람과 m단의 사다리 높이를 입력받는다.
- [x] 사다리는 2차원 배열로 표현한다. 
  - [x] 사다리의 가로대(디딤대) 위치에는 랜덤값에 따라 공백 또는 대시(-) 문자가 들어간다.
  - [x] 사다리의 세로대(버팀대) 위치에는 | 문자가 들어간다. 
- [x] 사다리 상태를 화면에 출력한다. 

### 추가 고려사항

- 입출력을 별도의 객체로 분리하는 것이 좋을까?
  - 그렇다고 한다면 구체적으로 어떻게 분리해야 좋을까?
  - main 메서드에서는 어떤 흐름으로 입출력을 호출해야 할까?
  - 출력을 담당하는 객체(뷰?)는 호출의 주체(출력하기 위해 출력에 필요한 내용을 요청)여야 할까, 호출의 대상(프로그램의 흐름에 따라 출력할 것이 있을 때 출력 메서드를 호출)이어야 할까?

## 2단계 - 리펙토링 맛보기

### 요구사항

- [x] 메서드의 크기가 최대 10라인을 넘지 않도록 구현한다.
- [x] 메서드가 한 가지 일만 하도록 최대한 작게 만들어라.
- [x] 들여쓰기(indent) depth를 2단계에서 1단계로 줄여라.
  - depth의 경우 if 문을 사용하는 경우 1단계의 depth가 증가한다. 
  - if 문 안에 while 문을 사용한다면 depth가 2단계가 된다.
- [x] else를 사용하지 마라.
- [x] 구현 순서를 고려하면서 프로그래밍한다.
- [x] naming convention을 지키면서 프로그래밍한다.
  - camel toe 방식
  - 클래스 머리글자는 대문자
  - 클래스/변수명은 명사, 메서드명은 동사

### 추가 고려사항

- 출력할 메시지를 하나의 상수 메시지에 몰아담았는데 (게임에서 string을 테이블에 보관하는 것을 모방했다) 메시지와 관련된 클래스에 상수 필드로 담는 것이 나았을까?
- 참조형 필드를 getter로 객체 외부에 유출시키지 말아야 한다고 생각하여 캐릭터 배열 -> 문자열 변환을 Ladder 내부에서 처리하도록 하였는데, 객체의 역할 분담이 잘 된 것일까?

## 3단계 - 사다리 모양 개선

### 요구사항

- [x] 이전 단계까지의 리팩토링 기준을 준수한다. 
- [x] 배열 대신 ArrayList와 Generics를 이용하여 구현한다. 
- [x] 사다리 게임에 참여하는 플레이어의 이름을 최대 5글자까지 부여할 수 있다.
  - 플레이어 수 대신 이름 목록으로 입력받는다.
  - 사람 이름은 쉼표(,)를 기준으로 구분한다.
- [x] 사다리 출력시 이름도 같이 출력한다.
  - 사람 이름을 5자 기준으로 출력하기 때문에 사다리 폭도 넓어져야 한다.
- [x] 사다리 타기가 정상적으로 동작하려면 라인이 겹치지 않도록 해야 한다.
  - 예를 들어 `|-----|-----|` 모양과 같이 가로 라인이 겹치는 경우 어느 방향으로 이동할지 결정할 수 없다.

### 추가 고려사항

- 가로줄의 생성 여부를 Random::nextBoolean으로 판단하는데, 불리언 대신 랜덤 숫자를 생성한 뒤 판정 범위를 지정함으로써 바이어스를 줄 수 있으면 어떨까?

## 4단계 - 리팩토링 2

### 요구사항 

- [x] 이전 단계까지의 요구사항을 만족한다.
- [x] 로직을 구현하는 코드에 단위 테스트가 존재해야 한다. 
  - 단, UI 처리 로직(System.in, System.out)은 테스트에서 제외한다.
- [x] 각각의 역할에 맞도록 패키지를 분리하고 접근 제어자를 적절히 사용하도록 리팩토링한다.

## 5단계 - 실행결과 출력

### 요구사항

- [x] 이전 단계까지의 요구사항을 만족한다.
- [x] 사다리 실행 결과를 출력해야 한다. 
  - 개인별 이름을 입력하면 개인별 결과를 출력한다. 
  - "all"을 입력하면 전체 참여자의 실행 결과를 출력한다. 
- [x] 이름에 "춘식이"를 입력하면 프로그램을 종료한다.
- [x] setter 메소드를 사용하지 않고 구현한다.
  - 단, DTO(Data Transfer Object)는 setter를 사용해도 무방하다.

### 4단계 PR 피드백

- 도메인과 출력의 책임분리가 미흡하다. 
- 접근제어자의 활용이 미숙하다.
- JUnit 내장 assertion 대신 AssertJ를 사용해 보자.
- 단위 테스트를 @ParameterizedTest로 개선한다.
- 단위 테스트는 자동화되어 있어야 하며 출력한 내용을 직접 확인할 필요가 없어야 한다.
- .idea/java-ladder.iml 파일은 버전관리에 포함할 필요가 없다.
  - 개인화된 설정을 다루고 있으며, auto-import 시 자동으로 생성되는 파일이기도 하다.

## 실행결과 예제

```shell
참여할 사람 이름을 입력하십시오. (각 항목 사이에는 ','를 넣어 구분해주십시오.)
DJ,Dummy,Sam,Kaar,Corry
결과 목록을 입력하십시오. 참여하는 사람 수를 초과하는 분량의 결과는 무시됩니다. (각 항목 사이에는 ','를 넣어 구분해주십시오.)
100,200,300,0
사다리의 높이를 입력하십시오.
15

*DJ    *Dummy *Sam   *Kaar  *Corry 
|------|      |------|      |
|      |      |------|      |
|------|      |      |      |
|------|      |------|      |
|      |------|      |------|
|      |      |      |------|
|------|      |      |      |
|      |------|      |------|
|------|      |      |------|
|------|      |------|      |
|      |      |------|      |
|      |      |      |      |
|------|      |------|      |
|      |      |      |      |
|------|      |------|      |
*100   *200   *300   *0     *      

결과를 보고 싶은 사람은?
DJ
실행 결과
200  

결과를 보고 싶은 사람은?
Dummy
실행 결과
300  

결과를 보고 싶은 사람은?
Sam
실행 결과
0    

결과를 보고 싶은 사람은?
Kaar
실행 결과
100  

결과를 보고 싶은 사람은?
Corry
실행 결과
     

결과를 보고 싶은 사람은?
all
실행 결과
DJ    : 200  
Dummy : 300  
Sam   : 0    
Kaar  : 100  
Corry :      

결과를 보고 싶은 사람은?
춘식이
굶주린 야생의 춘식이(이)가 사다리를 먹어치웠다. 다음은 내 차례다. 나를 기억해ㅈ -END-
Process finished with exit code 
```